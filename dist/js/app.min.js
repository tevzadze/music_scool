/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/js/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/js/app.js":
/*!***********************!*\
  !*** ./app/js/app.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// // import Scene from '../libs/tree/scene';\n// import $ from 'jquery'\n// window.jQuery = $\n// window.$ = $\n// import 'magnific-popup'\n// import gsap from 'gsap'\n// import { ScrollTrigger } from \"gsap/ScrollTrigger\"\n// // import FontFaceObserver from \"fontfaceobserver\";\n// // import imagesLoaded from \"imagesLoaded\";\n// // import * as THREE from 'three';\n// gsap.registerPlugin(ScrollTrigger);\n// document.addEventListener('DOMContentLoaded', () => {\n// \t// Custom JS\n// \t//preloader function\n// \tlet preloader = document.querySelector('.preloader')\n// \twindow.onload = function () {\n// \t\tsetTimeout(function () {\n// \t\t\tdocument.body.classList.add('loaded2');\n// \t\t\tsetTimeout(function () {\n// \t\t\t\tpreloader.remove()\n// \t\t\t}, 300)\n// \t\t}, 1200);\n// \t}\n// \t//offset from bottom of viewport\n// \tfunction inViewport(item, min, max) {\n// \t\tlet y = item.getBoundingClientRect().top\n// \t\tlet itemHeight = item.getBoundingClientRect().height\n// \t\tlet wh = window.innerHeight\n// \t\tlet bot = (-(y - wh)) - itemHeight / 2\n// \t\tlet top = y + itemHeight / 2\n// \t\tif (bot > min & top > max) {\n// \t\t\treturn true\n// \t\t} else {\n// \t\t\treturn false\n// \t\t}\n// \t}\n// \t//faq function\n// \tlet questions = document.querySelectorAll('.openQuestion')\n// \tlet answers = document.querySelectorAll('.contentQuestion')\n// \tfor (let i = 0; i < questions.length; i++) {\n// \t\tquestions[i].addEventListener('click', function () {\n// \t\t\tanswers[i].classList.toggle('active')\n// \t\t\tquestions[i].classList.toggle('active')\n// \t\t})\n// \t}\n// \t//open chars\n// \tfunction openOsChars() {\n// \t\tlet osButtons = document.querySelectorAll('.os span')\n// \t\tlet osWrappers = document.querySelectorAll('.os-list')\n// \t\tlet closeButton = document.querySelectorAll('.os-list .close')\n// \t\tfor (let i = 0; i < osButtons.length; i++) {\n// \t\t\tosButtons[i].addEventListener('click', function () {\n// \t\t\t\tif (!osButtons[i].classList.contains('active')) {\n// \t\t\t\t\tfor (let i = 0; i < osButtons.length; i++) {\n// \t\t\t\t\t\tosWrappers[i].classList.remove('active')\n// \t\t\t\t\t\tosButtons[i].classList.remove('active')\n// \t\t\t\t\t}\n// \t\t\t\t\tosWrappers[i].classList.add('active')\n// \t\t\t\t\tosButtons[i].classList.add('active')\n// \t\t\t\t} else {\n// \t\t\t\t\tfor (let i = 0; i < osButtons.length; i++) {\n// \t\t\t\t\t\tosWrappers[i].classList.remove('active')\n// \t\t\t\t\t\tosButtons[i].classList.remove('active')\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t})\n// \t\t\tcloseButton[i].addEventListener('click', function () {\n// \t\t\t\tosButtons[i].classList.remove('active')\n// \t\t\t\tosWrappers[i].classList.remove('active')\n// \t\t\t})\n// \t\t}\n// \t}\n// \topenOsChars()\n// \t//video play button function\n// \tlet playButton = document.querySelectorAll('.play')\n// \tlet videos = document.querySelectorAll('video')\n// \tfor (let i = 0; i < playButton.length; i++) {\n// \t\tplayButton[i].addEventListener('click', function () {\n// \t\t\tvideos[i].setAttribute(\"controls\", \"controls\")\n// \t\t\tvideos[i].play()\n// \t\t\tplayButton[i].classList.add('inactive')\n// \t\t})\n// \t}\n// \t//video scale\n// \tlet heroVideo = document.querySelector('.hero-section-video')\n// \tif (document.querySelector('main').classList.contains('home')) {\n// \t\tgsap.to(heroVideo, {\n// \t\t\tscale: 1.2,\n// \t\t\tduration: .3,\n// \t\t\tscrollTrigger: {\n// \t\t\t\ttrigger: heroVideo,\n// \t\t\t\tscrub: true,\n// \t\t\t\tstart: 'top bottom',\n// \t\t\t\tend: 'center center',\n// \t\t\t\t// marks: true\n// \t\t\t}\n// \t\t})\n// \t}\n// \t//enroll-sctoll-button\n// \tlet enrollLink = document.querySelector('.enrollButton')\n// \tif (enrollLink) {\n// \t\tenrollLink.addEventListener(\"click\", clickHandler);\n// \t}\n// \tfunction clickHandler(e) {\n// \t\te.preventDefault();\n// \t\tconst href = this.getAttribute(\"href\");\n// \t\tconst offsetTop = document.querySelector(href).offsetTop;\n// \t\tscroll({\n// \t\t\ttop: offsetTop,\n// \t\t\tbehavior: \"smooth\"\n// \t\t});\n// \t}\n// \t//inview animations\n// \tlet marks = document.querySelector('.advantages-section-pics')\n// \tlet nameIsStan = document.querySelector('.story-section-text')\n// \tlet myStory = document.querySelector('.roll-block')\n// \tlet cariculum = document.querySelectorAll('.lesson-section-main-element')\n// \twindow.addEventListener('scroll', function () {\n// \t\t//cariculum animation \n// \t\tif (!document.querySelector('main').classList.contains('home')) {\n// \t\t\treturn;\n// \t\t}\n// \t\tfor (let i = 0; i < 2; i++) {\n// \t\t\tif (inViewport(cariculum[i], -200, -200)) {\n// \t\t\t\tcariculum[i].classList.add('visible')\n// \t\t\t} else if (cariculum[i].classList.contains('visible')) {\n// \t\t\t\tcariculum[i].classList.remove('visible')\n// \t\t\t}\n// \t\t}\n// \t\t// my name is..\n// \t\tif (inViewport(nameIsStan, -200, -200) && !myStory.classList.contains('visible')) {\n// \t\t\tmyStory.classList.add('visible')\n// \t\t\t// console.log('adddded')\n// \t\t} else if (!inViewport(nameIsStan, -220, -220) && myStory.classList.contains('visible')) {\n// \t\t\tmyStory.classList.remove('visible')\n// \t\t}\n// \t\t//Big marks\n// \t\tif (inViewport(marks, 100, 100) && !marks.classList.contains('visible')) {\n// \t\t\tmarks.classList.add('visible')\n// \t\t\t// console.log('marks move')\n// \t\t} else if (!inViewport(marks, 100, 100) && marks.classList.contains('visible')) {\n// \t\t\tmarks.classList.remove('visible')\n// \t\t\t// console.log('marks reset')\n// \t\t}\n// \t})\n// \t//popup function\n// \tif ($('.popup-with-move-anim').length > 0) {\n// \t\t$('.popup-with-move-anim').magnificPopup({\n// \t\t\ttype: 'inline',\n// \t\t\tfixedContentPos: true,\n// \t\t\tfixedBgPos: true,\n// \t\t\toverflowY: 'auto',\n// \t\t\tcloseBtnInside: true,\n// \t\t\tpreloader: false,\n// \t\t\tmidClick: true,\n// \t\t\tremovalDelay: 300,\n// \t\t\tmainClass: 'my-mfp-slide-bottom'\n// \t\t});\n// \t}\n// \t$('#small-dialog .button-wrapper').on(\"click\", function () {\n// \t\t// preventDefault();\n// \t\t$.magnificPopup.close();\n// \t});\n// })\n// // function animscene() {\n// // \tconst scene = new Scene(\"anim-container\");\n// // \t// helper functions\n// // \tconst MathUtils = {\n// // \t\t// map number x from range [a, b] to [c, d]\n// // \t\tmap: (x, a, b, c, d) => ((x - a) * (d - c)) / (b - a) + c,\n// // \t\t// linear interpolation\n// // \t\tlerp: (a, b, n) => (1 - n) * a + n * b\n// // \t};\n// // \t// body element\n// // \tconst body = document.body;\n// // \tlet IMAGES;\n// // \t// calculate the viewport size\n// // \tlet winsize;\n// // \tconst calcWinsize = () =>\n// // \t\t(winsize = { width: window.innerWidth, height: window.innerHeight });\n// // \tcalcWinsize();\n// // \t// and recalculate on resize\n// // \twindow.addEventListener(\"resize\", calcWinsize);\n// // \twindow.onbeforeunload = function () {\n// // \t\twindow.scrollTo(0, 0);\n// // \t};\n// // \t// scroll position and update function\n// // \tlet docScroll;\n// // \tconst getPageYScroll = () =>\n// // \t\t(docScroll = window.pageYOffset || document.documentElement.scrollTop);\n// // \twindow.addEventListener(\"scroll\", getPageYScroll);\n// // \t// Item\n// // \tclass Item {\n// // \t\tconstructor(el, scroll) {\n// // \t\t\t// the .item element\n// // \t\t\tthis.scroll = scroll;\n// // \t\t\tthis.DOM = { el: el.img };\n// // \t\t\tthis.currentScroll = docScroll;\n// // \t\t\tthis.animated = false;\n// // \t\t\tthis.isBeingAnimatedNow = false;\n// // \t\t\tthis.shouldRollBack = false;\n// // \t\t\tthis.shouldUnRoll = false;\n// // \t\t\tthis.positions = [];\n// // \t\t\t// set the initial values\n// // \t\t\tthis.getSize();\n// // \t\t\tthis.mesh = scene.createMesh({\n// // \t\t\t\twidth: this.width,\n// // \t\t\t\theight: this.height,\n// // \t\t\t\tsrc: this.src,\n// // \t\t\t\timage: this.DOM.el,\n// // \t\t\t\tiWidth: this.DOM.el.width,\n// // \t\t\t\tiHeight: this.DOM.el.height\n// // \t\t\t});\n// // \t\t\tscene.scene.add(this.mesh);\n// // \t\t\t// use the IntersectionObserver API to check when the element is inside the viewport\n// // \t\t\t// only then the element translation will be updated\n// // \t\t\tthis.intersectionRatio;\n// // \t\t\tlet options = {\n// // \t\t\t\troot: null,\n// // \t\t\t\trootMargin: \"0px\",\n// // \t\t\t\tthreshold: [0, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n// // \t\t\t};\n// // \t\t\tthis.observer = new IntersectionObserver(entries => {\n// // \t\t\t\tentries.forEach(entry => {\n// // \t\t\t\t\tthis.positions.push(entry.boundingClientRect.y);\n// // \t\t\t\t\tlet compareArray = this.positions.slice(\n// // \t\t\t\t\t\tthis.positions.length - 2,\n// // \t\t\t\t\t\tthis.positions.length\n// // \t\t\t\t\t);\n// // \t\t\t\t\tlet down = compareArray[0] > compareArray[1] ? true : false;\n// // \t\t\t\t\tthis.isVisible = entry.intersectionRatio > 0.0;\n// // \t\t\t\t\tthis.shouldRollBack = false;\n// // \t\t\t\t\tthis.shouldUnRoll = false;\n// // \t\t\t\t\tif (\n// // \t\t\t\t\t\tentry.intersectionRatio < 0.5 &&\n// // \t\t\t\t\t\tentry.boundingClientRect.y > 0 &&\n// // \t\t\t\t\t\tthis.isVisible &&\n// // \t\t\t\t\t\t!down\n// // \t\t\t\t\t) {\n// // \t\t\t\t\t\tthis.shouldRollBack = true;\n// // \t\t\t\t\t}\n// // \t\t\t\t\tif (\n// // \t\t\t\t\t\tentry.intersectionRatio > 0.5 &&\n// // \t\t\t\t\t\tentry.boundingClientRect.y > 0 &&\n// // \t\t\t\t\t\tthis.isVisible\n// // \t\t\t\t\t) {\n// // \t\t\t\t\t\tthis.shouldUnRoll = true;\n// // \t\t\t\t\t}\n// // \t\t\t\t\tconsole.log(this.isVisible, 'vis');\n// // \t\t\t\t\tthis.mesh.visible = this.isVisible;\n// // \t\t\t\t});\n// // \t\t\t}, options);\n// // \t\t\tthis.observer.observe(this.DOM.el);\n// // \t\t\t// init/bind events\n// // \t\t\twindow.addEventListener(\"resize\", () => this.resize());\n// // \t\t\tthis.render(0);\n// // \t\t}\n// // \t\tgetSize() {\n// // \t\t\t// get all the sizes here, bounds and all\n// // \t\t\tconst bounds = this.DOM.el.getBoundingClientRect();\n// // \t\t\tconst fromTop = bounds.top;\n// // \t\t\tconst windowHeight = window.innerHeight;\n// // \t\t\tconst withoutHeight = fromTop - windowHeight;\n// // \t\t\tconst withHeight = fromTop + bounds.height;\n// // \t\t\tthis.insideTop = withoutHeight - docScroll;\n// // \t\t\tthis.insideRealTop = fromTop + docScroll;\n// // \t\t\tthis.insideBottom = withHeight - docScroll + 50;\n// // \t\t\tthis.width = bounds.width;\n// // \t\t\tthis.height = bounds.height;\n// // \t\t\tthis.left = bounds.left;\n// // \t\t}\n// // \t\tresize() {\n// // \t\t\t// on resize rest sizes and update the translation value\n// // \t\t\tthis.getSize();\n// // \t\t\tthis.mesh.scale.set(this.width, this.height, 200);\n// // \t\t\tthis.render(this.scroll.renderedStyles.translationY.current);\n// // \t\t\tthis.scroll.shouldRender = true;\n// // \t\t}\n// // \t\trender(currentScroll) {\n// // \t\t\tthis.currentScroll = currentScroll;\n// // \t\t\tthis.mesh.position.y =\n// // \t\t\t\tcurrentScroll + winsize.height / 2 - this.insideRealTop - this.height / 2;\n// // \t\t\tthis.mesh.position.x = 0 - winsize.width / 2 + this.left + this.width / 2;\n// // \t\t}\n// // \t}\n// // \t// SmoothScroll\n// // \tclass SmoothScroll {\n// // \t\tconstructor() {\n// // \t\t\tthis.shouldRender = false;\n// // \t\t\t// the <main> element\n// // \t\t\tthis.DOM = { main: document.querySelector(\"main\") };\n// // \t\t\t// the scrollable element\n// // \t\t\t// we translate this element when scrolling (y-axis)\n// // \t\t\tthis.DOM.scrollable = this.DOM.main.querySelector(\"div[data-scroll]\");\n// // \t\t\t// the items on the page\n// // \t\t\tthis.items = [];\n// // \t\t\tthis.createItems();\n// // \t\t\tthis.listenMouse()\n// // \t\t\t// here we define which property will change as we scroll the page\n// // \t\t\t// in this case we will be translating on the y-axis\n// // \t\t\t// we interpolate between the previous and current value to achieve the smooth scrolling effect\n// // \t\t\tthis.renderedStyles = {\n// // \t\t\t\ttranslationY: {\n// // \t\t\t\t\t// interpolated value\n// // \t\t\t\t\tprevious: 0,\n// // \t\t\t\t\t// current value\n// // \t\t\t\t\tcurrent: 0,\n// // \t\t\t\t\t// amount to interpolate\n// // \t\t\t\t\tease: 0.1,\n// // \t\t\t\t\t// current value setter\n// // \t\t\t\t\t// in this case the value of the translation will be the same like the document scroll\n// // \t\t\t\t\tsetValue: () => docScroll\n// // \t\t\t\t}\n// // \t\t\t};\n// // \t\t\t// set the body's height\n// // \t\t\tthis.setSize();\n// // \t\t\t// set the initial values\n// // \t\t\tthis.update();\n// // \t\t\t// the <main> element's style needs to be modified\n// // \t\t\tthis.style();\n// // \t\t\t// init/bind events\n// // \t\t\tthis.initEvents();\n// // \t\t\t// start the render loop\n// // \t\t\trequestAnimationFrame(() => this.render());\n// // \t\t}\n// // \t\tlistenMouse() {\n// // \t\t\tdocument.addEventListener('mousemove', () => {\n// // \t\t\t\tthis.shouldRender = true;\n// // \t\t\t})\n// // \t\t}\n// // \t\tupdate() {\n// // \t\t\t// sets the initial value (no interpolation) - translate the scroll value\n// // \t\t\tfor (const key in this.renderedStyles) {\n// // \t\t\t\tthis.renderedStyles[key].current = this.renderedStyles[\n// // \t\t\t\t\tkey\n// // \t\t\t\t].previous = this.renderedStyles[key].setValue();\n// // \t\t\t}\n// // \t\t\t// translate the scrollable element\n// // \t\t\tthis.setPosition();\n// // \t\t\tthis.shouldRender = true;\n// // \t\t}\n// // \t\tsetPosition() {\n// // \t\t\t// translates the scrollable element\n// // \t\t\tif (\n// // \t\t\t\tMath.round(this.renderedStyles.translationY.previous) !==\n// // \t\t\t\tMath.round(this.renderedStyles.translationY.current) ||\n// // \t\t\t\tthis.renderedStyles.translationY.previous < 10\n// // \t\t\t) {\n// // \t\t\t\tthis.shouldRender = true;\n// // \t\t\t\tthis.DOM.scrollable.style.transform = `translate3d(0,${-1 *\n// // \t\t\t\t\tthis.renderedStyles.translationY.previous}px,0)`;\n// // \t\t\t\t// console.log(this.items);\n// // \t\t\t\tfor (const item of this.items) {\n// // \t\t\t\t\t// if the item is inside the viewport call it's render function\n// // \t\t\t\t\t// this will update the item's inner image translation, based on the document scroll value and the item's position on the viewport\n// // \t\t\t\t\tif (item.isVisible || item.isBeingAnimatedNow) {\n// // \t\t\t\t\t\titem.render(this.renderedStyles.translationY.previous);\n// // \t\t\t\t\t}\n// // \t\t\t\t}\n// // \t\t\t}\n// // \t\t\t;\n// // \t\t\tif (scene.targetSpeed > 0.01) this.shouldRender = true;\n// // \t\t\tif (this.shouldRender) {\n// // \t\t\t\tthis.shouldRender = false;\n// // \t\t\t\tscene.render();\n// // \t\t\t}\n// // \t\t}\n// // \t\tsetSize() {\n// // \t\t\t// set the heigh of the body in order to keep the scrollbar on the page\n// // \t\t\t// console.log(this.DOM.scrollable.scrollHeight, 'HEIGHT');\n// // \t\t\tbody.style.height = `${this.DOM.scrollable.scrollHeight}px`;\n// // \t\t}\n// // \t\tcreateItems() {\n// // \t\t\tIMAGES.forEach(image => {\n// // \t\t\t\tif (image.img.classList.contains(\"js-image\")) {\n// // \t\t\t\t\tthis.items.push(new Item(image, this));\n// // \t\t\t\t}\n// // \t\t\t});\n// // \t\t}\n// // \t\tstyle() {\n// // \t\t\t// the <main> needs to \"stick\" to the screen and not scroll\n// // \t\t\t// for that we set it to position fixed and overflow hidden\n// // \t\t\tthis.DOM.main.style.position = \"fixed\";\n// // \t\t\tthis.DOM.main.style.width = this.DOM.main.style.height = \"100%\";\n// // \t\t\tthis.DOM.main.style.top = this.DOM.main.style.left = 0;\n// // \t\t\tthis.DOM.main.style.overflow = \"hidden\";\n// // \t\t}\n// // \t\tinitEvents() {\n// // \t\t\t// on resize reset the body's height\n// // \t\t\twindow.addEventListener(\"resize\", () => this.setSize());\n// // \t\t}\n// // \t\trender() {\n// // \t\t\t// update the current and interpolated values\n// // \t\t\tfor (const key in this.renderedStyles) {\n// // \t\t\t\tthis.renderedStyles[key].current = this.renderedStyles[key].setValue();\n// // \t\t\t\tthis.renderedStyles[key].previous = MathUtils.lerp(\n// // \t\t\t\t\tthis.renderedStyles[key].previous,\n// // \t\t\t\t\tthis.renderedStyles[key].current,\n// // \t\t\t\t\tthis.renderedStyles[key].ease\n// // \t\t\t\t);\n// // \t\t\t}\n// // \t\t\t// and translate the scrollable element\n// // \t\t\tthis.setPosition();\n// // \t\t\t// loop..\n// // \t\t\trequestAnimationFrame(() => this.render());\n// // \t\t}\n// // \t}\n// // \t/***********************************/\n// // \t/********** Preload stuff **********/\n// // \t// const fontParalucent = new FontFaceObserver(\"laca-text\").load()/\n// // \t// const fontStarling = new FontFaceObserver(\"operetta-12\").load()\n// // \t// Preload images\n// // \tconst preloadImages = new Promise((resolve, reject) => {\n// // \t\timagesLoaded(document.querySelectorAll(\"img\"), { background: true }, resolve);\n// // \t});\n// // \tpreloadImages.then(images => {\n// // \t\tIMAGES = images.images;\n// // \t});\n// // \tconst preloadEverything = [preloadImages];\n// // \t// And then..\n// // \tPromise.all(preloadEverything).then(() => {\n// // \t\t// Remove the loader\n// // \t\tdocument.body.classList.remove(\"loading\");\n// // \t\tdocument.body.classList.add(\"loaded\");\n// // \t\t// Get the scroll position\n// // \t\tgetPageYScroll();\n// // \t\t// Initialize the Smooth Scrolling\n// // \t\tnew SmoothScroll();\n// // \t});\n// // }\n// // animscene()\n// // function myTry() {\n// // \tconst scene = new THREE.Scene();\n// // \tconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n// // \tconst renderer = new THREE.WebGLRenderer();\n// // \trenderer.setSize(window.innerWidth, window.innerHeight);\n// // \tdocument.body.appendChild(renderer.domElement);\n// // \tlet TEXTURE = new THREE.TextureLoader().load('../images/dist/lines3.png');\n// // \t// let mesh = new Mesh(\n// // \t// \tnew PlaneBufferGeometry(),\n// // \t// \tnew MeshBasicMaterial({ map: TEXTURE })\n// // \t// )\n// // \tconst geometry = new THREE.PlaneBufferGeometry(5,20,32)\n// // \tconst material = new THREE.MeshBasicMaterial({ map: TEXTURE })\n// // \tconst item = new THREE.Mesh(geometry, material);\n// // \tscene.add(item);\n// // \tcamera.position.z = 5;\n// // \tfunction animate() {\n// // \t\trequestAnimationFrame(animate);\n// // \t\t// item.rotation.x += 0.01;\n// // \t\t// item.rotation.y += 0.01;\n// // \t\trenderer.render(scene, camera);\n// // \t}\n// // \tanimate();\n// // }\n// // myTry()\n\n//# sourceURL=webpack:///./app/js/app.js?");

/***/ })

/******/ });